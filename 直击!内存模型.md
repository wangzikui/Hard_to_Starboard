## 直击!内存模型

#### 从物理机内存模型说起

​	**模型:**当CPU（处理器）要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找

<img src="/Users/skedush/Library/Mobile Documents/com~apple~CloudDocs/豆知识/image/cpu物理内存模型.png" alt="cpu物理内存模型" style="zoom:33%;" />

**多线程中的问题:**每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存,这时CPU缓存中的值可能和缓存中的值不一样，这就会出现缓存不一致的问题。

**解决方案**:

(1)总线加**LOCK#**锁:每个线程访问高速缓存都会对总线上锁,禁止其他线程访问高速缓存												     (2)缓存一致性协议:当CPU写数据时，如果发现操作的变量是共享变量，会发出信号通知其他CPU将该变量的缓存行置为无效，此时当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行无效，会从内存重新读取。

**乱序执行:**CPU(处理器)还采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。目的是为了使CPU内部电路满负荷运转并相应提高了CPU的运行程序的速度。例如泡面先加水还是先加料包都无所谓.

#### java内存模型

<img src="/Users/skedush/Library/Mobile Documents/com~apple~CloudDocs/豆知识/image/java内存模型.png" alt="java内存模型" style="zoom:50%;" />

- 主内存：主要存储变量（包括。实例字段，静态字段和构成对象的元素）
- 工作内存：每个线程都有自己的工作内存，存储了对应的引用，方法参数。

如果对应与Java内存中堆与栈的概念的话，**主内存对应Java内存中的堆，工作内存对应Java虚拟机的栈。**

#### 主内存与工作内存的交互:8个原子操作

#### <img src="/Users/skedush/Library/Mobile Documents/com~apple~CloudDocs/豆知识/image/java内存交互操作.png" alt="java内存交互操作" style="zoom:33%;" />

> lock：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
>
> unlock：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才能被其他线程访问。
>
> read：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，一遍随后的load动作使用。
>
> load：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入到工作内存变量副本中。
>
> use：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作。
>
> assign：作用于工作内存的变量，它把一个从执行引擎收到的值赋给工作内存的变量。每当虚拟机遇到给变量赋值的字节码指令时会执行这个操作。
>
> store：作用于工作内存的变量，它把工作内存中一个变量值传送到主内存中。以便随后的write操作。
>
> write：作用于主内存的变量，它把store操作从工作内存中得到的变量的值，放入主内存的变量中。

操作的规则:

> - 不允许read和load、store和write操作之一单独出现。即不允许一个变量从主内存读取了但工作内存不接受。或者从工作内存发起回写了但主内存不接受的情况
> - 不允许一个线程丢弃它的最近的assign操作。即变量在工作内存改变了后必须把该变化同步到主内存中。
> - 不允许没有发生任何的assign操作就把数据同步到主内存中。
> - 一个新的变量只能在主内存中诞生，工作内存要使用或者赋值。必须要经过load或assign操作。
> - 一个变量在同一时刻只允许一条线程进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
> - 如果对一个变量进行lock操作后，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作。
> - 如果一个变量事先没有被lock操作锁定，那就不允许对它进行unlock操作。也不允许去unlock一个被其他线程锁定的变量。
> - 对一个变量执行unLock操作之前，必须要把次变量同步到主内存中（执行store,write操作）。
>
> 上述规则规定了Java内存之间交互的流程。保证了数据**在单线程情形下**传输过程中的准确性与数据一致性。

#### 重排序:

​	**重排序规则:**编译器与处理器只会对**没有数据依赖性**的指令进行重排序

​	**数据依赖性:**两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。

```java
//例:
double a = 3;//底	
double h = 10;//高	
double s = a*h/2;//面积	
//a与s存在数据依赖关系，同时h与s也存在依赖关系。因此在程序的最终指令执行时。s是不能排在a与h之前。因为a与h不存在着数据依赖关系。所以处理器可以对a与h之前的执行顺序重排序。
```

#### java内存模型需要解决的问题

- **可见性:**当多个线程操作同一个共享变量时，如果一个线程修改了其中的变量的值,另一个线程可能保持着之前获取的值，另一个线程怎么感知呢？

- **重排序:**

  ```java
  //例:
  public class Demo {
      private int a = 0;
      private boolean isInit = false;
      private Config config;
  
      public void init() {		//线程A执行
          config = readConfig();//1
          isInit = true;//2
      }
      public void doSomething() {		//线程B执行
          if (isInit) {//3
              doSomethingWithconfig();//4
          }
      }
  }
  //如操作顺序2->3->4->1(即线程A将12反序)则会导致空指针
  ```

#### 解决方案:Happen—Before

Happens-Before原则是一组**偏序关系**：对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是**可见**的**(不能说A先于B发生)**

> - 单线程happen-before原则：在**同一个线程**中，书写在前面的操作happen-before后面的操作。
>
> **注**:这里的操作是指**有读写依赖**的操作,无依赖的操作还是会重排序
>
> - 锁的happen-before原则：**同一个锁**的unlock操作happen-before此锁的lock操作。
>
> **注**:同一个资源被释放锁,这个行为会被其他对该资源的争用线程感知到
>
> - volatile的happen-before原则：对一个**volatile**变量的**写操作**happen-before对此变量的任意操作
> - happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。
> - 线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。
> - 线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。
> - 线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。
>
> **注**:线程结束时,他所做的所有修改对外部线程可见.(join结束的场景)
>
> - 对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。
>
> ### 一言以蔽之,这些规则背后的道理:
>
> ```
> 在程序运行过程中，所有的变更会先在寄存器或本地cache中完成，然后才会被拷贝到主存以跨越内存栅栏（本地或工作内存到主存之间的拷贝动作），此种跨越序列或顺序称为happens-before。
> ```
>
> **注：happens-before本质是顺序，重点是跨越内存栅栏**