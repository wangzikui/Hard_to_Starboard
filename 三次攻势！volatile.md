## 三次攻势！volatile

- **作用1：线程的可见性：**当一个变量定义为volatile后，那么该变量对所有线程都是“可见的”，其中“可见的”是指当一条线程修改了这个变量的值，那么新值对于其他线程来说是可以立即知道的。

  **原理：**用volatile修饰变量时，生成的汇编指令会比普通的变量声明会多一个**Lock**指令。那么**Lock**指令会在多核处理器下会做两件事情。

  ​		1:将当前处理器缓存行的数据直接写会到系统内存中（从Java内存模型来理解，就是将线程中的工作内存的数据直接写入到主内存中）

  ​		2:这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效（从Java内存模型理解，当线程A将工作内存的数据修改后（新值），同步到主内存中，那么线程B从主内存中初始的值（旧值）就无效了）

- **作用2:防止重排序：**使用volatile来修饰相应变量时，可以防止CPU(处理器)在处理指令的时候禁止重排序。

  volatile写之前的操作不会被编译器重排序到volatile写之后。

  volatile读之后的操作不会被编译器重排序到volatile读之前。

  当第一个操作是volatile写，第二个操作如果是volatile读时，不能进行重排序。

  **原理：内存屏障**：

  ##### 内存屏障插入策略

  下面是基于volatile修饰的变量，编译器在指令序列插入的内存屏障**保守插入策略**如下：

  - 在每个volatile写操作的前面插入一个storestore屏障。
  - 在每个volatile写操作的后面插入一个storeload屏障。
  - 在每个volatile读操作的后面插入一个loadload屏障。
  - 在每个volatile读操作的后面插入一个loadstore屏障。

#### 禁区！volatile不具有原子性！

在有多个操作的情况下，CPU可能先暂停然后在调度的，对i++这种复合操作来说，volatile不能保证原子性。例如多线程中，一个线程讲i的原值读入工作内存后被cpu剥夺，另一个线程改了i值，此时该线程恢复后，不会再读一次i值。

#### volatile使用场景

在轻量级线程同步中我们可以使用volatile关键字。但是有两个前提条件：

- 第一个条件：运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值,如**i++**
- 第二个条件：变量不需要与其他的状态变量共同参与不变约束。如**双指针协同**